/**
 * LockfileManager Property-Based Tests
 * 
 * Property-based tests for the LockfileManager service using fast-check.
 * These tests verify correctness properties that should hold for all valid inputs.
 * 
 * Properties covered:
 * - Property 2: Lockfile Schema Validation (Requirements 4.2-4.7, 11.1-11.4, 15.1-15.2)
 * - Property 3: Lockfile Round-Trip Consistency (Requirements 4.1, 5.2, 5.5)
 * - Property 7: Checksum Modification Detection (Requirements 14.1-14.3)
 * - Property 12: Source and Hub Configuration Completeness (Requirements 12.1-12.6)
 * - Property 15: Atomic Lockfile Write (Requirements 15.6)
 */

import * as assert from 'assert';
import * as fc from 'fast-check';
import * as fs from 'fs';
import * as path from 'path';
import * as crypto from 'crypto';
import {
    LockfileBuilder,
    LockfileGenerators,
    createMockLockfile,
    LOCKFILE_DEFAULTS
} from '../helpers/lockfileTestHelpers';
import { PropertyTestConfig } from '../helpers/propertyTestHelpers';
import { Lockfile } from '../../src/types/lockfile';
import { SchemaValidator } from '../../src/services/SchemaValidator';

suite('LockfileManager Property Tests', () => {
    let tempDir: string;
    let schemaValidator: SchemaValidator;
    const lockfileSchemaPath = path.join(process.cwd(), 'schemas', 'lockfile.schema.json');

    // ===== Test Utilities =====
    const createTempDir = (): string => {
        const dir = path.join(__dirname, '..', '..', 'test-temp-lockfile-prop-' + Date.now());
        fs.mkdirSync(dir, { recursive: true });
        return dir;
    };

    const cleanupTempDir = (dir: string): void => {
        if (fs.existsSync(dir)) {
            fs.rmSync(dir, { recursive: true, force: true });
        }
    };

    setup(() => {
        tempDir = createTempDir();
        schemaValidator = new SchemaValidator(process.cwd());
    });

    teardown(() => {
        cleanupTempDir(tempDir);
        schemaValidator.clearCache();
    });

    /**
     * Property 2: Lockfile Schema Validation
     * 
     * For any lockfile generated by the extension, it SHALL be valid JSON with
     * required fields ($schema, version, generatedAt, generatedBy, bundles, sources)
     * and use 2-space indentation.
     * 
     * **Validates: Requirements 4.2-4.7, 11.1-11.4, 15.1-15.2**
     */
    suite('Property 2: Lockfile Schema Validation', () => {
        test('generated lockfiles should be valid against JSON schema', async () => {
            await fc.assert(
                fc.asyncProperty(
                    LockfileGenerators.consistentLockfile({ minBundles: 1, maxBundles: 3 }),
                    async (lockfile: Lockfile) => {
                        // Validate against JSON schema
                        const result = await schemaValidator.validate(lockfile, lockfileSchemaPath);
                        
                        // Property: All generated lockfiles should be schema-valid
                        assert.strictEqual(
                            result.valid,
                            true,
                            `Schema validation failed: ${result.errors.join(', ')}`
                        );
                        return true;
                    }
                ),
                {
                    ...PropertyTestConfig.FAST_CHECK_OPTIONS,
                    numRuns: PropertyTestConfig.RUNS.STANDARD
                }
            );
        });

        test('lockfiles should have all required fields', async () => {
            await fc.assert(
                fc.asyncProperty(
                    LockfileGenerators.lockfile({ minBundles: 0, maxBundles: 3 }),
                    async (lockfile: Lockfile) => {
                        // Property: All required fields must be present
                        assert.ok(lockfile.$schema, 'Missing $schema field');
                        assert.ok(lockfile.version, 'Missing version field');
                        assert.ok(lockfile.generatedAt, 'Missing generatedAt field');
                        assert.ok(lockfile.generatedBy, 'Missing generatedBy field');
                        assert.ok(lockfile.bundles !== undefined, 'Missing bundles field');
                        assert.ok(lockfile.sources !== undefined, 'Missing sources field');
                        return true;
                    }
                ),
                {
                    ...PropertyTestConfig.FAST_CHECK_OPTIONS,
                    numRuns: PropertyTestConfig.RUNS.STANDARD
                }
            );
        });

        test('version field should be semver-compatible', async () => {
            await fc.assert(
                fc.asyncProperty(
                    LockfileGenerators.lockfile(),
                    async (lockfile: Lockfile) => {
                        // Property: Version should match semver pattern
                        const semverPattern = /^\d+\.\d+\.\d+$/;
                        assert.ok(
                            semverPattern.test(lockfile.version),
                            `Version "${lockfile.version}" is not semver-compatible`
                        );
                        return true;
                    }
                ),
                {
                    ...PropertyTestConfig.FAST_CHECK_OPTIONS,
                    numRuns: PropertyTestConfig.RUNS.STANDARD
                }
            );
        });

        test('generatedAt should be valid ISO timestamp', async () => {
            await fc.assert(
                fc.asyncProperty(
                    LockfileGenerators.lockfile(),
                    async (lockfile: Lockfile) => {
                        // Property: generatedAt should be parseable as ISO date
                        const date = new Date(lockfile.generatedAt);
                        assert.ok(
                            !isNaN(date.getTime()),
                            `generatedAt "${lockfile.generatedAt}" is not a valid ISO timestamp`
                        );
                        return true;
                    }
                ),
                {
                    ...PropertyTestConfig.FAST_CHECK_OPTIONS,
                    numRuns: PropertyTestConfig.RUNS.STANDARD
                }
            );
        });

        test('bundle entries should have all required fields', async () => {
            await fc.assert(
                fc.asyncProperty(
                    LockfileGenerators.consistentLockfile({ minBundles: 1, maxBundles: 3 }),
                    async (lockfile: Lockfile) => {
                        // Property: Each bundle entry must have required fields
                        for (const [bundleId, entry] of Object.entries(lockfile.bundles)) {
                            assert.ok(entry.version, `Bundle ${bundleId} missing version`);
                            assert.ok(entry.sourceId, `Bundle ${bundleId} missing sourceId`);
                            assert.ok(entry.sourceType, `Bundle ${bundleId} missing sourceType`);
                            assert.ok(entry.installedAt, `Bundle ${bundleId} missing installedAt`);
                            assert.ok(entry.commitMode, `Bundle ${bundleId} missing commitMode`);
                            assert.ok(Array.isArray(entry.files), `Bundle ${bundleId} files should be array`);
                        }
                        return true;
                    }
                ),
                {
                    ...PropertyTestConfig.FAST_CHECK_OPTIONS,
                    numRuns: PropertyTestConfig.RUNS.STANDARD
                }
            );
        });

        test('file checksums should be valid SHA256 format', async () => {
            await fc.assert(
                fc.asyncProperty(
                    LockfileGenerators.consistentLockfile({ minBundles: 1, maxBundles: 2 }),
                    async (lockfile: Lockfile) => {
                        // Property: All file checksums should be 64 hex characters
                        const sha256Pattern = /^[a-f0-9]{64}$/;
                        for (const [bundleId, entry] of Object.entries(lockfile.bundles)) {
                            for (const file of entry.files) {
                                assert.ok(
                                    sha256Pattern.test(file.checksum),
                                    `File ${file.path} in bundle ${bundleId} has invalid checksum format`
                                );
                            }
                        }
                        return true;
                    }
                ),
                {
                    ...PropertyTestConfig.FAST_CHECK_OPTIONS,
                    numRuns: PropertyTestConfig.RUNS.STANDARD
                }
            );
        });
    });

    /**
     * Property 3: Lockfile Round-Trip Consistency
     * 
     * For any valid lockfile, reading then writing (without modifications)
     * SHALL produce an equivalent lockfile.
     * 
     * **Validates: Requirements 4.1, 5.2, 5.5**
     */
    suite('Property 3: Lockfile Round-Trip Consistency', () => {
        // Helper to normalize lockfile by removing undefined values (JSON doesn't preserve them)
        const normalizeLockfile = (lockfile: Lockfile): Lockfile => {
            return JSON.parse(JSON.stringify(lockfile));
        };

        test('JSON stringify then parse should preserve lockfile structure', async () => {
            await fc.assert(
                fc.asyncProperty(
                    LockfileGenerators.consistentLockfile({ minBundles: 1, maxBundles: 3 }),
                    async (lockfile: Lockfile) => {
                        // Property: JSON round-trip should preserve structure
                        // Note: undefined values are not preserved in JSON
                        const serialized = JSON.stringify(lockfile, null, 2);
                        const deserialized = JSON.parse(serialized) as Lockfile;
                        const normalized = normalizeLockfile(lockfile);
                        
                        // Deep equality check (comparing normalized versions)
                        assert.deepStrictEqual(
                            deserialized,
                            normalized,
                            'Round-trip should preserve lockfile structure'
                        );
                        return true;
                    }
                ),
                {
                    ...PropertyTestConfig.FAST_CHECK_OPTIONS,
                    numRuns: PropertyTestConfig.RUNS.STANDARD
                }
            );
        });

        test('file write then read should preserve lockfile content', async () => {
            await fc.assert(
                fc.asyncProperty(
                    LockfileGenerators.consistentLockfile({ minBundles: 1, maxBundles: 2 }),
                    async (lockfile: Lockfile) => {
                        // Property: File I/O round-trip should preserve content
                        const lockfilePath = path.join(tempDir, `lockfile-${Date.now()}.json`);
                        const normalized = normalizeLockfile(lockfile);
                        
                        // Write to file
                        fs.writeFileSync(lockfilePath, JSON.stringify(lockfile, null, 2));
                        
                        // Read back
                        const content = fs.readFileSync(lockfilePath, 'utf8');
                        const readLockfile = JSON.parse(content) as Lockfile;
                        
                        // Verify equality (comparing normalized versions)
                        assert.deepStrictEqual(
                            readLockfile,
                            normalized,
                            'File round-trip should preserve lockfile content'
                        );
                        
                        // Cleanup
                        fs.unlinkSync(lockfilePath);
                        return true;
                    }
                ),
                {
                    ...PropertyTestConfig.FAST_CHECK_OPTIONS,
                    numRuns: PropertyTestConfig.RUNS.QUICK
                }
            );
        });

        test('2-space indentation should be preserved', async () => {
            await fc.assert(
                fc.asyncProperty(
                    LockfileGenerators.consistentLockfile({ minBundles: 1, maxBundles: 2 }),
                    async (lockfile: Lockfile) => {
                        // Property: 2-space indentation should be used
                        const serialized = JSON.stringify(lockfile, null, 2);
                        
                        // Check for 2-space indentation pattern
                        const lines = serialized.split('\n');
                        const indentedLines = lines.filter(line => line.startsWith('  '));
                        
                        // Should have indented lines if there's content
                        if (Object.keys(lockfile.bundles).length > 0 || Object.keys(lockfile.sources).length > 0) {
                            assert.ok(
                                indentedLines.length > 0,
                                'Should have 2-space indented lines'
                            );
                        }
                        return true;
                    }
                ),
                {
                    ...PropertyTestConfig.FAST_CHECK_OPTIONS,
                    numRuns: PropertyTestConfig.RUNS.QUICK
                }
            );
        });
    });

    /**
     * Property 15: Atomic Lockfile Write
     * 
     * For any lockfile update operation, the write SHALL be atomic
     * (using temp file + rename pattern) to prevent corruption during
     * concurrent operations or crashes.
     * 
     * **Validates: Requirements 15.6**
     */
    suite('Property 15: Atomic Lockfile Write', () => {
        // Helper to normalize lockfile by removing undefined values (JSON doesn't preserve them)
        const normalizeLockfile = (lockfile: Lockfile): Lockfile => {
            return JSON.parse(JSON.stringify(lockfile));
        };

        test('atomic write pattern should not corrupt existing lockfile on failure', async () => {
            await fc.assert(
                fc.asyncProperty(
                    LockfileGenerators.consistentLockfile({ minBundles: 1, maxBundles: 2 }),
                    LockfileGenerators.consistentLockfile({ minBundles: 1, maxBundles: 2 }),
                    async (originalLockfile: Lockfile, newLockfile: Lockfile) => {
                        const lockfilePath = path.join(tempDir, `atomic-test-${Date.now()}.json`);
                        const tempPath = lockfilePath + '.tmp';
                        
                        // Normalize to remove undefined values (JSON doesn't preserve them)
                        const normalizedNew = normalizeLockfile(newLockfile);
                        
                        // Write original lockfile
                        fs.writeFileSync(lockfilePath, JSON.stringify(originalLockfile, null, 2));
                        
                        // Simulate atomic write pattern
                        // 1. Write to temp file
                        fs.writeFileSync(tempPath, JSON.stringify(newLockfile, null, 2));
                        
                        // 2. Rename temp to target (atomic on most filesystems)
                        fs.renameSync(tempPath, lockfilePath);
                        
                        // Property: After atomic write, file should contain new content
                        const content = fs.readFileSync(lockfilePath, 'utf8');
                        const readLockfile = JSON.parse(content) as Lockfile;
                        
                        assert.deepStrictEqual(
                            readLockfile,
                            normalizedNew,
                            'Atomic write should result in new lockfile content'
                        );
                        
                        // Cleanup
                        fs.unlinkSync(lockfilePath);
                        return true;
                    }
                ),
                {
                    ...PropertyTestConfig.FAST_CHECK_OPTIONS,
                    numRuns: PropertyTestConfig.RUNS.QUICK
                }
            );
        });

        test('temp file should not exist after successful atomic write', async () => {
            await fc.assert(
                fc.asyncProperty(
                    LockfileGenerators.consistentLockfile({ minBundles: 1, maxBundles: 2 }),
                    async (lockfile: Lockfile) => {
                        const lockfilePath = path.join(tempDir, `atomic-cleanup-${Date.now()}.json`);
                        const tempPath = lockfilePath + '.tmp';
                        
                        // Simulate atomic write
                        fs.writeFileSync(tempPath, JSON.stringify(lockfile, null, 2));
                        fs.renameSync(tempPath, lockfilePath);
                        
                        // Property: Temp file should not exist after rename
                        assert.strictEqual(
                            fs.existsSync(tempPath),
                            false,
                            'Temp file should not exist after atomic write'
                        );
                        
                        // Cleanup
                        fs.unlinkSync(lockfilePath);
                        return true;
                    }
                ),
                {
                    ...PropertyTestConfig.FAST_CHECK_OPTIONS,
                    numRuns: PropertyTestConfig.RUNS.QUICK
                }
            );
        });
    });

    /**
     * Property 7: Checksum Modification Detection
     * 
     * For any installed bundle with recorded checksums, comparing current vs stored
     * checksums SHALL correctly identify modified, missing, and new files.
     * 
     * **Validates: Requirements 14.1-14.3**
     */
    suite('Property 7: Checksum Modification Detection', () => {
        test('identical content should produce identical checksums', async () => {
            await fc.assert(
                fc.asyncProperty(
                    fc.string({ minLength: 1, maxLength: 1000 }),
                    async (content: string) => {
                        // Property: Same content should always produce same checksum
                        const checksum1 = crypto.createHash('sha256').update(content).digest('hex');
                        const checksum2 = crypto.createHash('sha256').update(content).digest('hex');
                        
                        assert.strictEqual(
                            checksum1,
                            checksum2,
                            'Identical content should produce identical checksums'
                        );
                        return true;
                    }
                ),
                {
                    ...PropertyTestConfig.FAST_CHECK_OPTIONS,
                    numRuns: PropertyTestConfig.RUNS.STANDARD
                }
            );
        });

        test('different content should produce different checksums', async () => {
            await fc.assert(
                fc.asyncProperty(
                    fc.string({ minLength: 1, maxLength: 500 }),
                    fc.string({ minLength: 1, maxLength: 500 }),
                    async (content1: string, content2: string) => {
                        // Skip if contents are identical
                        fc.pre(content1 !== content2);
                        
                        // Property: Different content should produce different checksums
                        const checksum1 = crypto.createHash('sha256').update(content1).digest('hex');
                        const checksum2 = crypto.createHash('sha256').update(content2).digest('hex');
                        
                        assert.notStrictEqual(
                            checksum1,
                            checksum2,
                            'Different content should produce different checksums'
                        );
                        return true;
                    }
                ),
                {
                    ...PropertyTestConfig.FAST_CHECK_OPTIONS,
                    numRuns: PropertyTestConfig.RUNS.STANDARD
                }
            );
        });

        test('file modification should be detectable via checksum comparison', async () => {
            await fc.assert(
                fc.asyncProperty(
                    fc.string({ minLength: 1, maxLength: 500 }),
                    fc.string({ minLength: 1, maxLength: 500 }),
                    async (originalContent: string, modifiedContent: string) => {
                        // Skip if contents are identical
                        fc.pre(originalContent !== modifiedContent);
                        
                        const filePath = path.join(tempDir, `checksum-test-${Date.now()}.txt`);
                        
                        // Write original content and calculate checksum
                        fs.writeFileSync(filePath, originalContent);
                        const originalChecksum = crypto.createHash('sha256')
                            .update(fs.readFileSync(filePath))
                            .digest('hex');
                        
                        // Modify file
                        fs.writeFileSync(filePath, modifiedContent);
                        const currentChecksum = crypto.createHash('sha256')
                            .update(fs.readFileSync(filePath))
                            .digest('hex');
                        
                        // Property: Modification should be detectable
                        const isModified = originalChecksum !== currentChecksum;
                        assert.strictEqual(
                            isModified,
                            true,
                            'File modification should be detectable via checksum'
                        );
                        
                        // Cleanup
                        fs.unlinkSync(filePath);
                        return true;
                    }
                ),
                {
                    ...PropertyTestConfig.FAST_CHECK_OPTIONS,
                    numRuns: PropertyTestConfig.RUNS.QUICK
                }
            );
        });

        test('missing file should be detectable', async () => {
            await fc.assert(
                fc.asyncProperty(
                    fc.string({ minLength: 1, maxLength: 100 }),
                    async (content: string) => {
                        const filePath = path.join(tempDir, `missing-test-${Date.now()}.txt`);
                        
                        // Write file and get checksum
                        fs.writeFileSync(filePath, content);
                        const originalChecksum = crypto.createHash('sha256')
                            .update(fs.readFileSync(filePath))
                            .digest('hex');
                        
                        // Delete file
                        fs.unlinkSync(filePath);
                        
                        // Property: Missing file should be detectable
                        const fileExists = fs.existsSync(filePath);
                        assert.strictEqual(
                            fileExists,
                            false,
                            'Missing file should be detectable'
                        );
                        
                        return true;
                    }
                ),
                {
                    ...PropertyTestConfig.FAST_CHECK_OPTIONS,
                    numRuns: PropertyTestConfig.RUNS.QUICK
                }
            );
        });
    });

    /**
     * Property 12: Source and Hub Configuration Completeness
     * 
     * For any lockfile with bundle entries, corresponding source entries
     * SHALL exist in the sources section.
     * 
     * **Validates: Requirements 12.1-12.6**
     */
    suite('Property 12: Source and Hub Configuration Completeness', () => {
        test('all bundle sourceIds should reference existing sources', async () => {
            await fc.assert(
                fc.asyncProperty(
                    LockfileGenerators.consistentLockfile({ minBundles: 1, maxBundles: 5 }),
                    async (lockfile: Lockfile) => {
                        // Property: Every bundle's sourceId should exist in sources
                        for (const [bundleId, entry] of Object.entries(lockfile.bundles)) {
                            assert.ok(
                                lockfile.sources[entry.sourceId],
                                `Bundle ${bundleId} references non-existent source ${entry.sourceId}`
                            );
                        }
                        return true;
                    }
                ),
                {
                    ...PropertyTestConfig.FAST_CHECK_OPTIONS,
                    numRuns: PropertyTestConfig.RUNS.STANDARD
                }
            );
        });

        test('source entries should have required type and url fields', async () => {
            await fc.assert(
                fc.asyncProperty(
                    LockfileGenerators.consistentLockfile({ minBundles: 1, maxBundles: 3 }),
                    async (lockfile: Lockfile) => {
                        // Property: All sources should have type and url
                        for (const [sourceId, source] of Object.entries(lockfile.sources)) {
                            assert.ok(
                                source.type,
                                `Source ${sourceId} missing type field`
                            );
                            assert.ok(
                                source.url,
                                `Source ${sourceId} missing url field`
                            );
                        }
                        return true;
                    }
                ),
                {
                    ...PropertyTestConfig.FAST_CHECK_OPTIONS,
                    numRuns: PropertyTestConfig.RUNS.STANDARD
                }
            );
        });

        test('hub entries should have required name and url fields', async () => {
            await fc.assert(
                fc.asyncProperty(
                    LockfileGenerators.lockfile({ minBundles: 1, maxBundles: 2, includeHubs: true }),
                    async (lockfile: Lockfile) => {
                        // Property: All hubs should have name and url
                        if (lockfile.hubs) {
                            for (const [hubId, hub] of Object.entries(lockfile.hubs)) {
                                assert.ok(
                                    hub.name,
                                    `Hub ${hubId} missing name field`
                                );
                                assert.ok(
                                    hub.url,
                                    `Hub ${hubId} missing url field`
                                );
                            }
                        }
                        return true;
                    }
                ),
                {
                    ...PropertyTestConfig.FAST_CHECK_OPTIONS,
                    numRuns: PropertyTestConfig.RUNS.STANDARD
                }
            );
        });

        test('profile entries should have required name and bundleIds fields', async () => {
            await fc.assert(
                fc.asyncProperty(
                    LockfileGenerators.lockfile({ minBundles: 1, maxBundles: 2, includeProfiles: true }),
                    async (lockfile: Lockfile) => {
                        // Property: All profiles should have name and bundleIds
                        if (lockfile.profiles) {
                            for (const [profileId, profile] of Object.entries(lockfile.profiles)) {
                                assert.ok(
                                    profile.name,
                                    `Profile ${profileId} missing name field`
                                );
                                assert.ok(
                                    Array.isArray(profile.bundleIds),
                                    `Profile ${profileId} bundleIds should be array`
                                );
                            }
                        }
                        return true;
                    }
                ),
                {
                    ...PropertyTestConfig.FAST_CHECK_OPTIONS,
                    numRuns: PropertyTestConfig.RUNS.STANDARD
                }
            );
        });

        test('source types should be valid known types', async () => {
            const validSourceTypes = [
                'github', 'gitlab', 'http', 'local',
                'awesome-copilot', 'local-awesome-copilot',
                'apm', 'local-apm', 'olaf', 'local-olaf'
            ];

            await fc.assert(
                fc.asyncProperty(
                    LockfileGenerators.consistentLockfile({ minBundles: 1, maxBundles: 3 }),
                    async (lockfile: Lockfile) => {
                        // Property: All source types should be valid
                        for (const [sourceId, source] of Object.entries(lockfile.sources)) {
                            assert.ok(
                                validSourceTypes.includes(source.type),
                                `Source ${sourceId} has invalid type: ${source.type}`
                            );
                        }
                        return true;
                    }
                ),
                {
                    ...PropertyTestConfig.FAST_CHECK_OPTIONS,
                    numRuns: PropertyTestConfig.RUNS.STANDARD
                }
            );
        });
    });

    /**
     * Property 3 (Lockfile Source of Truth): LockfileBundleEntry to InstalledBundle Conversion
     * 
     * For any valid LockfileBundleEntry, converting it to InstalledBundle format SHALL produce
     * an object with all required fields (bundleId, version, sourceId, sourceType, installedAt,
     * scope, installPath).
     * 
     * **Validates: Requirements 1.3**
     * 
     * Feature: lockfile-source-of-truth, Property 3: LockfileBundleEntry to InstalledBundle Conversion
     */
    suite('Property 3: LockfileBundleEntry to InstalledBundle Conversion', () => {
        test('converted InstalledBundle should have all required fields', async () => {
            await fc.assert(
                fc.asyncProperty(
                    LockfileGenerators.consistentLockfile({ minBundles: 1, maxBundles: 5 }),
                    async (lockfile: Lockfile) => {
                        // Write lockfile to temp directory
                        const lockfilePath = path.join(tempDir, 'prompt-registry.lock.json');
                        fs.writeFileSync(lockfilePath, JSON.stringify(lockfile, null, 2));

                        // Get installed bundles using LockfileManager
                        const { LockfileManager } = await import('../../src/services/LockfileManager');
                        LockfileManager.resetInstance(tempDir);
                        const manager = LockfileManager.getInstance(tempDir);
                        
                        const installedBundles = await manager.getInstalledBundles();

                        // Property: Each converted bundle should have all required fields
                        for (const bundle of installedBundles) {
                            assert.ok(bundle.bundleId, 'Missing bundleId field');
                            assert.ok(bundle.version, 'Missing version field');
                            assert.ok(bundle.sourceId, 'Missing sourceId field');
                            assert.ok(bundle.sourceType, 'Missing sourceType field');
                            assert.ok(bundle.installedAt, 'Missing installedAt field');
                            assert.ok(bundle.scope, 'Missing scope field');
                            assert.ok(bundle.installPath, 'Missing installPath field');
                            assert.ok(bundle.manifest, 'Missing manifest field');
                        }

                        // Cleanup
                        LockfileManager.resetInstance(tempDir);
                        fs.unlinkSync(lockfilePath);
                        return true;
                    }
                ),
                {
                    ...PropertyTestConfig.FAST_CHECK_OPTIONS,
                    numRuns: PropertyTestConfig.RUNS.STANDARD
                }
            );
        });

        test('scope should always be repository for lockfile bundles', async () => {
            await fc.assert(
                fc.asyncProperty(
                    LockfileGenerators.consistentLockfile({ minBundles: 1, maxBundles: 3 }),
                    async (lockfile: Lockfile) => {
                        // Write lockfile to temp directory
                        const lockfilePath = path.join(tempDir, 'prompt-registry.lock.json');
                        fs.writeFileSync(lockfilePath, JSON.stringify(lockfile, null, 2));

                        // Get installed bundles using LockfileManager
                        const { LockfileManager } = await import('../../src/services/LockfileManager');
                        LockfileManager.resetInstance(tempDir);
                        const manager = LockfileManager.getInstance(tempDir);
                        
                        const installedBundles = await manager.getInstalledBundles();

                        // Property: All bundles from lockfile should have scope 'repository'
                        for (const bundle of installedBundles) {
                            assert.strictEqual(
                                bundle.scope,
                                'repository',
                                `Bundle ${bundle.bundleId} should have scope 'repository', got '${bundle.scope}'`
                            );
                        }

                        // Cleanup
                        LockfileManager.resetInstance(tempDir);
                        fs.unlinkSync(lockfilePath);
                        return true;
                    }
                ),
                {
                    ...PropertyTestConfig.FAST_CHECK_OPTIONS,
                    numRuns: PropertyTestConfig.RUNS.STANDARD
                }
            );
        });

        test('installPath should be constructed from workspace root + .github', async () => {
            await fc.assert(
                fc.asyncProperty(
                    LockfileGenerators.consistentLockfile({ minBundles: 1, maxBundles: 3 }),
                    async (lockfile: Lockfile) => {
                        // Write lockfile to temp directory
                        const lockfilePath = path.join(tempDir, 'prompt-registry.lock.json');
                        fs.writeFileSync(lockfilePath, JSON.stringify(lockfile, null, 2));

                        // Get installed bundles using LockfileManager
                        const { LockfileManager } = await import('../../src/services/LockfileManager');
                        LockfileManager.resetInstance(tempDir);
                        const manager = LockfileManager.getInstance(tempDir);
                        
                        const installedBundles = await manager.getInstalledBundles();

                        // Property: installPath should end with .github
                        const expectedPath = path.join(tempDir, '.github');
                        for (const bundle of installedBundles) {
                            assert.strictEqual(
                                bundle.installPath,
                                expectedPath,
                                `Bundle ${bundle.bundleId} installPath should be '${expectedPath}', got '${bundle.installPath}'`
                            );
                        }

                        // Cleanup
                        LockfileManager.resetInstance(tempDir);
                        fs.unlinkSync(lockfilePath);
                        return true;
                    }
                ),
                {
                    ...PropertyTestConfig.FAST_CHECK_OPTIONS,
                    numRuns: PropertyTestConfig.RUNS.STANDARD
                }
            );
        });

        test('version and sourceId should match lockfile entry', async () => {
            await fc.assert(
                fc.asyncProperty(
                    LockfileGenerators.consistentLockfile({ minBundles: 1, maxBundles: 3 }),
                    async (lockfile: Lockfile) => {
                        // Write lockfile to temp directory
                        const lockfilePath = path.join(tempDir, 'prompt-registry.lock.json');
                        fs.writeFileSync(lockfilePath, JSON.stringify(lockfile, null, 2));

                        // Get installed bundles using LockfileManager
                        const { LockfileManager } = await import('../../src/services/LockfileManager');
                        LockfileManager.resetInstance(tempDir);
                        const manager = LockfileManager.getInstance(tempDir);
                        
                        const installedBundles = await manager.getInstalledBundles();

                        // Property: version and sourceId should match lockfile entry
                        for (const bundle of installedBundles) {
                            const lockfileEntry = lockfile.bundles[bundle.bundleId];
                            assert.ok(lockfileEntry, `Bundle ${bundle.bundleId} not found in lockfile`);
                            assert.strictEqual(
                                bundle.version,
                                lockfileEntry.version,
                                `Version mismatch for ${bundle.bundleId}`
                            );
                            assert.strictEqual(
                                bundle.sourceId,
                                lockfileEntry.sourceId,
                                `SourceId mismatch for ${bundle.bundleId}`
                            );
                            assert.strictEqual(
                                bundle.sourceType,
                                lockfileEntry.sourceType,
                                `SourceType mismatch for ${bundle.bundleId}`
                            );
                            // Note: commitMode is now determined by which lockfile the bundle comes from,
                            // not by the commitMode field in the entry (AD-1: Implicit Commit Mode Based on File Location)
                            // Bundles from main lockfile (prompt-registry.lock.json) always have commitMode: 'commit'
                            assert.strictEqual(
                                bundle.commitMode,
                                'commit',
                                `CommitMode for ${bundle.bundleId} should be 'commit' when read from main lockfile`
                            );
                        }

                        // Cleanup
                        LockfileManager.resetInstance(tempDir);
                        fs.unlinkSync(lockfilePath);
                        return true;
                    }
                ),
                {
                    ...PropertyTestConfig.FAST_CHECK_OPTIONS,
                    numRuns: PropertyTestConfig.RUNS.STANDARD
                }
            );
        });

        test('empty lockfile should return empty array', async () => {
            await fc.assert(
                fc.asyncProperty(
                    fc.constant(null), // No lockfile
                    async () => {
                        // Don't create a lockfile - test that getInstalledBundles returns empty array
                        const { LockfileManager } = await import('../../src/services/LockfileManager');
                        const uniqueDir = path.join(tempDir, `empty-${Date.now()}`);
                        fs.mkdirSync(uniqueDir, { recursive: true });
                        
                        LockfileManager.resetInstance(uniqueDir);
                        const manager = LockfileManager.getInstance(uniqueDir);
                        
                        const installedBundles = await manager.getInstalledBundles();

                        // Property: No lockfile should return empty array
                        assert.strictEqual(
                            installedBundles.length,
                            0,
                            'Should return empty array when lockfile does not exist'
                        );

                        // Cleanup
                        LockfileManager.resetInstance(uniqueDir);
                        fs.rmSync(uniqueDir, { recursive: true, force: true });
                        return true;
                    }
                ),
                {
                    ...PropertyTestConfig.FAST_CHECK_OPTIONS,
                    numRuns: PropertyTestConfig.RUNS.QUICK
                }
            );
        });
    });
});


/**
 * Lockfile Separation Property Tests
 * 
 * Property-based tests for the dual-lockfile separation feature.
 * These tests verify correctness properties for the local-only lockfile separation.
 * 
 * Properties covered:
 * - Property 1: Lockfile Separation (Requirements 1.1, 1.2)
 * - Property 2: No Duplicate Bundle IDs (Requirement 3.4)
 * - Property 3: Git Exclude Consistency (Requirements 2.1, 2.2)
 * - Property 4: Mode Switching Preserves Metadata (Requirement 4.3)
 * - Property 5: Empty Lockfile Cleanup (Requirements 5.3, 5.4, 5.5)
 * 
 * **Validates: Design Properties 1-5**
 */
suite('Lockfile Separation Properties', () => {
    let tempDir: string;
    const MAIN_LOCKFILE_NAME = 'prompt-registry.lock.json';
    const LOCAL_LOCKFILE_NAME = 'prompt-registry.local.lock.json';

    // ===== Test Utilities =====
    const createTempDir = (): string => {
        const dir = path.join(__dirname, '..', '..', 'test-temp-lockfile-sep-' + Date.now() + '-' + Math.random().toString(36).substring(7));
        fs.mkdirSync(dir, { recursive: true });
        return dir;
    };

    const cleanupTempDir = (dir: string): void => {
        if (fs.existsSync(dir)) {
            fs.rmSync(dir, { recursive: true, force: true });
        }
    };

    const createGitDir = (repoPath: string): void => {
        const gitInfoDir = path.join(repoPath, '.git', 'info');
        fs.mkdirSync(gitInfoDir, { recursive: true });
        fs.writeFileSync(path.join(gitInfoDir, 'exclude'), '# Git exclude file\n');
    };

    const readGitExclude = (repoPath: string): string => {
        const excludePath = path.join(repoPath, '.git', 'info', 'exclude');
        if (fs.existsSync(excludePath)) {
            return fs.readFileSync(excludePath, 'utf-8');
        }
        return '';
    };

    const lockfileExists = (repoPath: string, lockfileName: string): boolean => {
        return fs.existsSync(path.join(repoPath, lockfileName));
    };

    setup(() => {
        tempDir = createTempDir();
    });

    teardown(async () => {
        // Reset LockfileManager instances
        const { LockfileManager } = await import('../../src/services/LockfileManager');
        LockfileManager.resetInstance(tempDir);
        cleanupTempDir(tempDir);
    });

    /**
     * Property 1: Lockfile Separation
     * 
     * For any bundle creation with a specific commitMode:
     * - commitMode = 'commit' → bundleId ∈ mainLockfile.bundles
     * - commitMode = 'local-only' → bundleId ∈ localLockfile.bundles
     * 
     * **Validates: Requirements 1.1, 1.2**
     */
    suite('Property 1: Lockfile Separation', () => {
        test('bundles with commit mode should be written to main lockfile only', async () => {
            await fc.assert(
                fc.asyncProperty(
                    LockfileGenerators.bundleId(),
                    LockfileGenerators.version(),
                    LockfileGenerators.sourceId(),
                    LockfileGenerators.sourceType(),
                    async (bundleId: string, version: string, sourceId: string, sourceType: string) => {
                        const uniqueDir = path.join(tempDir, `commit-${Date.now()}-${Math.random().toString(36).substring(7)}`);
                        fs.mkdirSync(uniqueDir, { recursive: true });
                        createGitDir(uniqueDir);

                        const { LockfileManager } = await import('../../src/services/LockfileManager');
                        LockfileManager.resetInstance(uniqueDir);
                        const manager = LockfileManager.getInstance(uniqueDir);

                        // Create bundle with commit mode
                        await manager.createOrUpdate({
                            bundleId,
                            version,
                            sourceId,
                            sourceType,
                            commitMode: 'commit',
                            files: [],
                            source: { type: sourceType, url: `https://example.com/${sourceId}` }
                        });

                        // Property: Bundle should be in main lockfile
                        const mainLockfilePath = path.join(uniqueDir, MAIN_LOCKFILE_NAME);
                        const localLockfilePath = path.join(uniqueDir, LOCAL_LOCKFILE_NAME);

                        assert.ok(
                            fs.existsSync(mainLockfilePath),
                            'Main lockfile should exist after creating commit bundle'
                        );

                        const mainLockfile = JSON.parse(fs.readFileSync(mainLockfilePath, 'utf-8'));
                        assert.ok(
                            mainLockfile.bundles[bundleId],
                            `Bundle ${bundleId} should be in main lockfile`
                        );

                        // Property: Bundle should NOT be in local lockfile
                        assert.ok(
                            !fs.existsSync(localLockfilePath),
                            'Local lockfile should not exist for commit bundles'
                        );

                        // Cleanup
                        LockfileManager.resetInstance(uniqueDir);
                        cleanupTempDir(uniqueDir);
                        return true;
                    }
                ),
                {
                    ...PropertyTestConfig.FAST_CHECK_OPTIONS,
                    numRuns: PropertyTestConfig.RUNS.STANDARD
                }
            );
        });

        test('bundles with local-only mode should be written to local lockfile only', async () => {
            await fc.assert(
                fc.asyncProperty(
                    LockfileGenerators.bundleId(),
                    LockfileGenerators.version(),
                    LockfileGenerators.sourceId(),
                    LockfileGenerators.sourceType(),
                    async (bundleId: string, version: string, sourceId: string, sourceType: string) => {
                        const uniqueDir = path.join(tempDir, `local-${Date.now()}-${Math.random().toString(36).substring(7)}`);
                        fs.mkdirSync(uniqueDir, { recursive: true });
                        createGitDir(uniqueDir);

                        const { LockfileManager } = await import('../../src/services/LockfileManager');
                        LockfileManager.resetInstance(uniqueDir);
                        const manager = LockfileManager.getInstance(uniqueDir);

                        // Create bundle with local-only mode
                        await manager.createOrUpdate({
                            bundleId,
                            version,
                            sourceId,
                            sourceType,
                            commitMode: 'local-only',
                            files: [],
                            source: { type: sourceType, url: `https://example.com/${sourceId}` }
                        });

                        // Property: Bundle should be in local lockfile
                        const mainLockfilePath = path.join(uniqueDir, MAIN_LOCKFILE_NAME);
                        const localLockfilePath = path.join(uniqueDir, LOCAL_LOCKFILE_NAME);

                        assert.ok(
                            fs.existsSync(localLockfilePath),
                            'Local lockfile should exist after creating local-only bundle'
                        );

                        const localLockfile = JSON.parse(fs.readFileSync(localLockfilePath, 'utf-8'));
                        assert.ok(
                            localLockfile.bundles[bundleId],
                            `Bundle ${bundleId} should be in local lockfile`
                        );

                        // Property: Bundle should NOT be in main lockfile
                        assert.ok(
                            !fs.existsSync(mainLockfilePath),
                            'Main lockfile should not exist when only local-only bundles are installed'
                        );

                        // Cleanup
                        LockfileManager.resetInstance(uniqueDir);
                        cleanupTempDir(uniqueDir);
                        return true;
                    }
                ),
                {
                    ...PropertyTestConfig.FAST_CHECK_OPTIONS,
                    numRuns: PropertyTestConfig.RUNS.STANDARD
                }
            );
        });
    });

    /**
     * Property 2: No Duplicate Bundle IDs
     * 
     * For any bundleId: ¬(bundleId ∈ mainLockfile.bundles ∧ bundleId ∈ localLockfile.bundles)
     * 
     * A bundle ID can only exist in one lockfile at a time.
     * 
     * **Validates: Requirement 3.4**
     */
    suite('Property 2: No Duplicate Bundle IDs', () => {
        test('bundle ID can only exist in one lockfile at a time after mode switch', async () => {
            await fc.assert(
                fc.asyncProperty(
                    LockfileGenerators.bundleId(),
                    LockfileGenerators.version(),
                    LockfileGenerators.sourceId(),
                    LockfileGenerators.sourceType(),
                    LockfileGenerators.commitMode(),
                    async (bundleId: string, version: string, sourceId: string, sourceType: string, initialMode) => {
                        const uniqueDir = path.join(tempDir, `nodupe-${Date.now()}-${Math.random().toString(36).substring(7)}`);
                        fs.mkdirSync(uniqueDir, { recursive: true });
                        createGitDir(uniqueDir);

                        const { LockfileManager } = await import('../../src/services/LockfileManager');
                        LockfileManager.resetInstance(uniqueDir);
                        const manager = LockfileManager.getInstance(uniqueDir);

                        // Create bundle with initial mode
                        await manager.createOrUpdate({
                            bundleId,
                            version,
                            sourceId,
                            sourceType,
                            commitMode: initialMode,
                            files: [],
                            source: { type: sourceType, url: `https://example.com/${sourceId}` }
                        });

                        // Switch to opposite mode
                        const newMode = initialMode === 'commit' ? 'local-only' : 'commit';
                        await manager.updateCommitMode(bundleId, newMode);

                        // Property: Bundle should exist in exactly one lockfile
                        const mainLockfilePath = path.join(uniqueDir, MAIN_LOCKFILE_NAME);
                        const localLockfilePath = path.join(uniqueDir, LOCAL_LOCKFILE_NAME);

                        const mainExists = fs.existsSync(mainLockfilePath);
                        const localExists = fs.existsSync(localLockfilePath);

                        let inMain = false;
                        let inLocal = false;

                        if (mainExists) {
                            const mainLockfile = JSON.parse(fs.readFileSync(mainLockfilePath, 'utf-8'));
                            inMain = !!mainLockfile.bundles[bundleId];
                        }

                        if (localExists) {
                            const localLockfile = JSON.parse(fs.readFileSync(localLockfilePath, 'utf-8'));
                            inLocal = !!localLockfile.bundles[bundleId];
                        }

                        // Property: Bundle should be in exactly one lockfile (XOR)
                        assert.ok(
                            (inMain && !inLocal) || (!inMain && inLocal),
                            `Bundle ${bundleId} should exist in exactly one lockfile. In main: ${inMain}, In local: ${inLocal}`
                        );

                        // Cleanup
                        LockfileManager.resetInstance(uniqueDir);
                        cleanupTempDir(uniqueDir);
                        return true;
                    }
                ),
                {
                    ...PropertyTestConfig.FAST_CHECK_OPTIONS,
                    numRuns: PropertyTestConfig.RUNS.STANDARD
                }
            );
        });
    });

    /**
     * Property 3: Bundles from main lockfile always have commitMode 'commit' when listed
     * 
     * When listing bundles, bundles from the main lockfile should always have
     * commitMode: 'commit' set on them.
     * 
     * **Validates: Requirement 3.3**
     */
    suite('Property 3: Commit Mode Annotation from Main Lockfile', () => {
        test('bundles from main lockfile always have commitMode commit when listed', async () => {
            await fc.assert(
                fc.asyncProperty(
                    LockfileGenerators.bundleId(),
                    LockfileGenerators.version(),
                    LockfileGenerators.sourceId(),
                    LockfileGenerators.sourceType(),
                    async (bundleId: string, version: string, sourceId: string, sourceType: string) => {
                        const uniqueDir = path.join(tempDir, `main-mode-${Date.now()}-${Math.random().toString(36).substring(7)}`);
                        fs.mkdirSync(uniqueDir, { recursive: true });
                        createGitDir(uniqueDir);

                        const { LockfileManager } = await import('../../src/services/LockfileManager');
                        LockfileManager.resetInstance(uniqueDir);
                        const manager = LockfileManager.getInstance(uniqueDir);

                        // Create bundle with commit mode
                        await manager.createOrUpdate({
                            bundleId,
                            version,
                            sourceId,
                            sourceType,
                            commitMode: 'commit',
                            files: [],
                            source: { type: sourceType, url: `https://example.com/${sourceId}` }
                        });

                        // Get installed bundles
                        const installedBundles = await manager.getInstalledBundles();

                        // Property: Bundle from main lockfile should have commitMode 'commit'
                        const bundle = installedBundles.find(b => b.bundleId === bundleId);
                        assert.ok(bundle, `Bundle ${bundleId} should be in installed bundles`);
                        assert.strictEqual(
                            bundle!.commitMode,
                            'commit',
                            `Bundle ${bundleId} from main lockfile should have commitMode 'commit'`
                        );

                        // Cleanup
                        LockfileManager.resetInstance(uniqueDir);
                        cleanupTempDir(uniqueDir);
                        return true;
                    }
                ),
                {
                    ...PropertyTestConfig.FAST_CHECK_OPTIONS,
                    numRuns: PropertyTestConfig.RUNS.STANDARD
                }
            );
        });
    });

    /**
     * Property 4: Bundles from local lockfile always have commitMode 'local-only' when listed
     * 
     * When listing bundles, bundles from the local lockfile should always have
     * commitMode: 'local-only' set on them.
     * 
     * **Validates: Requirement 3.2**
     */
    suite('Property 4: Commit Mode Annotation from Local Lockfile', () => {
        test('bundles from local lockfile always have commitMode local-only when listed', async () => {
            await fc.assert(
                fc.asyncProperty(
                    LockfileGenerators.bundleId(),
                    LockfileGenerators.version(),
                    LockfileGenerators.sourceId(),
                    LockfileGenerators.sourceType(),
                    async (bundleId: string, version: string, sourceId: string, sourceType: string) => {
                        const uniqueDir = path.join(tempDir, `local-mode-${Date.now()}-${Math.random().toString(36).substring(7)}`);
                        fs.mkdirSync(uniqueDir, { recursive: true });
                        createGitDir(uniqueDir);

                        const { LockfileManager } = await import('../../src/services/LockfileManager');
                        LockfileManager.resetInstance(uniqueDir);
                        const manager = LockfileManager.getInstance(uniqueDir);

                        // Create bundle with local-only mode
                        await manager.createOrUpdate({
                            bundleId,
                            version,
                            sourceId,
                            sourceType,
                            commitMode: 'local-only',
                            files: [],
                            source: { type: sourceType, url: `https://example.com/${sourceId}` }
                        });

                        // Get installed bundles
                        const installedBundles = await manager.getInstalledBundles();

                        // Property: Bundle from local lockfile should have commitMode 'local-only'
                        const bundle = installedBundles.find(b => b.bundleId === bundleId);
                        assert.ok(bundle, `Bundle ${bundleId} should be in installed bundles`);
                        assert.strictEqual(
                            bundle!.commitMode,
                            'local-only',
                            `Bundle ${bundleId} from local lockfile should have commitMode 'local-only'`
                        );

                        // Cleanup
                        LockfileManager.resetInstance(uniqueDir);
                        cleanupTempDir(uniqueDir);
                        return true;
                    }
                ),
                {
                    ...PropertyTestConfig.FAST_CHECK_OPTIONS,
                    numRuns: PropertyTestConfig.RUNS.STANDARD
                }
            );
        });
    });

    /**
     * Property 5: Mode Switching Preserves Metadata
     * 
     * For any bundle, switching commit mode should preserve all metadata:
     * - version
     * - sourceId
     * - sourceType
     * - files
     * - checksum (if present)
     * 
     * **Validates: Requirement 4.3**
     */
    suite('Property 5: Mode Switching Preserves Metadata', () => {
        test('mode switching preserves all bundle metadata', async () => {
            await fc.assert(
                fc.asyncProperty(
                    LockfileGenerators.bundleId(),
                    LockfileGenerators.version(),
                    LockfileGenerators.sourceId(),
                    LockfileGenerators.sourceType(),
                    fc.array(LockfileGenerators.fileEntry(), { minLength: 0, maxLength: 3 }),
                    LockfileGenerators.commitMode(),
                    async (bundleId: string, version: string, sourceId: string, sourceType: string, files, initialMode) => {
                        const uniqueDir = path.join(tempDir, `preserve-${Date.now()}-${Math.random().toString(36).substring(7)}`);
                        fs.mkdirSync(uniqueDir, { recursive: true });
                        createGitDir(uniqueDir);

                        const { LockfileManager } = await import('../../src/services/LockfileManager');
                        LockfileManager.resetInstance(uniqueDir);
                        const manager = LockfileManager.getInstance(uniqueDir);

                        // Create bundle with initial mode
                        await manager.createOrUpdate({
                            bundleId,
                            version,
                            sourceId,
                            sourceType,
                            commitMode: initialMode,
                            files,
                            source: { type: sourceType, url: `https://example.com/${sourceId}` }
                        });

                        // Get original bundle data
                        const originalBundles = await manager.getInstalledBundles();
                        const originalBundle = originalBundles.find(b => b.bundleId === bundleId);
                        assert.ok(originalBundle, 'Original bundle should exist');

                        // Switch to opposite mode
                        const newMode = initialMode === 'commit' ? 'local-only' : 'commit';
                        await manager.updateCommitMode(bundleId, newMode);

                        // Get bundle after mode switch
                        const updatedBundles = await manager.getInstalledBundles();
                        const updatedBundle = updatedBundles.find(b => b.bundleId === bundleId);
                        assert.ok(updatedBundle, 'Updated bundle should exist');

                        // Property: All metadata should be preserved
                        assert.strictEqual(
                            updatedBundle!.version,
                            originalBundle!.version,
                            'Version should be preserved after mode switch'
                        );
                        assert.strictEqual(
                            updatedBundle!.sourceId,
                            originalBundle!.sourceId,
                            'SourceId should be preserved after mode switch'
                        );
                        assert.strictEqual(
                            updatedBundle!.sourceType,
                            originalBundle!.sourceType,
                            'SourceType should be preserved after mode switch'
                        );

                        // Property: Commit mode should be updated
                        assert.strictEqual(
                            updatedBundle!.commitMode,
                            newMode,
                            `CommitMode should be updated to ${newMode}`
                        );

                        // Cleanup
                        LockfileManager.resetInstance(uniqueDir);
                        cleanupTempDir(uniqueDir);
                        return true;
                    }
                ),
                {
                    ...PropertyTestConfig.FAST_CHECK_OPTIONS,
                    numRuns: PropertyTestConfig.RUNS.STANDARD
                }
            );
        });
    });

    /**
     * Property 6: Empty Lockfile Cleanup
     * 
     * For any lockfile (main or local):
     * |lockfile.bundles| = 0 → ¬fileExists(lockfile.path)
     * 
     * When a lockfile becomes empty (no bundles), it should be deleted.
     * 
     * **Validates: Requirements 5.3, 5.5**
     */
    suite('Property 6: Empty Lockfile Cleanup', () => {
        test('empty lockfile is deleted after removing last bundle', async () => {
            await fc.assert(
                fc.asyncProperty(
                    LockfileGenerators.bundleId(),
                    LockfileGenerators.version(),
                    LockfileGenerators.sourceId(),
                    LockfileGenerators.sourceType(),
                    LockfileGenerators.commitMode(),
                    async (bundleId: string, version: string, sourceId: string, sourceType: string, commitMode) => {
                        const uniqueDir = path.join(tempDir, `empty-${Date.now()}-${Math.random().toString(36).substring(7)}`);
                        fs.mkdirSync(uniqueDir, { recursive: true });
                        createGitDir(uniqueDir);

                        const { LockfileManager } = await import('../../src/services/LockfileManager');
                        LockfileManager.resetInstance(uniqueDir);
                        const manager = LockfileManager.getInstance(uniqueDir);

                        // Create bundle
                        await manager.createOrUpdate({
                            bundleId,
                            version,
                            sourceId,
                            sourceType,
                            commitMode,
                            files: [],
                            source: { type: sourceType, url: `https://example.com/${sourceId}` }
                        });

                        // Verify lockfile exists
                        const lockfileName = commitMode === 'local-only' ? LOCAL_LOCKFILE_NAME : MAIN_LOCKFILE_NAME;
                        const lockfilePath = path.join(uniqueDir, lockfileName);
                        assert.ok(
                            fs.existsSync(lockfilePath),
                            `Lockfile ${lockfileName} should exist after creating bundle`
                        );

                        // Remove the bundle
                        await manager.remove(bundleId);

                        // Property: Empty lockfile should be deleted
                        assert.ok(
                            !fs.existsSync(lockfilePath),
                            `Lockfile ${lockfileName} should be deleted after removing last bundle`
                        );

                        // Cleanup
                        LockfileManager.resetInstance(uniqueDir);
                        cleanupTempDir(uniqueDir);
                        return true;
                    }
                ),
                {
                    ...PropertyTestConfig.FAST_CHECK_OPTIONS,
                    numRuns: PropertyTestConfig.RUNS.STANDARD
                }
            );
        });

        test('lockfile with remaining bundles is not deleted', async () => {
            await fc.assert(
                fc.asyncProperty(
                    LockfileGenerators.bundleId(),
                    LockfileGenerators.bundleId(),
                    LockfileGenerators.version(),
                    LockfileGenerators.sourceId(),
                    LockfileGenerators.sourceType(),
                    LockfileGenerators.commitMode(),
                    async (bundleId1: string, bundleId2: string, version: string, sourceId: string, sourceType: string, commitMode) => {
                        // Ensure bundle IDs are different
                        fc.pre(bundleId1 !== bundleId2);

                        const uniqueDir = path.join(tempDir, `remain-${Date.now()}-${Math.random().toString(36).substring(7)}`);
                        fs.mkdirSync(uniqueDir, { recursive: true });
                        createGitDir(uniqueDir);

                        const { LockfileManager } = await import('../../src/services/LockfileManager');
                        LockfileManager.resetInstance(uniqueDir);
                        const manager = LockfileManager.getInstance(uniqueDir);

                        // Create two bundles with same commit mode
                        await manager.createOrUpdate({
                            bundleId: bundleId1,
                            version,
                            sourceId,
                            sourceType,
                            commitMode,
                            files: [],
                            source: { type: sourceType, url: `https://example.com/${sourceId}` }
                        });

                        await manager.createOrUpdate({
                            bundleId: bundleId2,
                            version,
                            sourceId,
                            sourceType,
                            commitMode,
                            files: [],
                            source: { type: sourceType, url: `https://example.com/${sourceId}` }
                        });

                        // Remove one bundle
                        await manager.remove(bundleId1);

                        // Property: Lockfile should still exist with remaining bundle
                        const lockfileName = commitMode === 'local-only' ? LOCAL_LOCKFILE_NAME : MAIN_LOCKFILE_NAME;
                        const lockfilePath = path.join(uniqueDir, lockfileName);
                        assert.ok(
                            fs.existsSync(lockfilePath),
                            `Lockfile ${lockfileName} should still exist with remaining bundle`
                        );

                        const lockfile = JSON.parse(fs.readFileSync(lockfilePath, 'utf-8'));
                        assert.ok(
                            lockfile.bundles[bundleId2],
                            `Bundle ${bundleId2} should still be in lockfile`
                        );
                        assert.ok(
                            !lockfile.bundles[bundleId1],
                            `Bundle ${bundleId1} should be removed from lockfile`
                        );

                        // Cleanup
                        LockfileManager.resetInstance(uniqueDir);
                        cleanupTempDir(uniqueDir);
                        return true;
                    }
                ),
                {
                    ...PropertyTestConfig.FAST_CHECK_OPTIONS,
                    numRuns: PropertyTestConfig.RUNS.STANDARD
                }
            );
        });
    });
});
